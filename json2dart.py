#!/usr/bin/python
# -*- coding:utf-8 -*-
# Author: WangLuofan

import os;
import sys;
import json;
import requests;
import subprocess;

param = None;
filePath = None;

class BuildRunnerProcess:
    def run(self):
        cmd = 'flutter packages pub run build_runner build --delete-conflicting-outputs';
        child = subprocess.Popen([cmd], shell = True, stdout = subprocess.PIPE);
        while child.poll() == None:
            print(child.stdout.readline());

        print('Generate Dart File Complete, Exiting....');
        print('File Path:' + '\033[31m ' + filePath + '\033[0m');

class FileOperator:
    def __init__(self):
        global filePath;

        target = os.path.join(param.getTarget(), 'lib');
        if(os.path.exists(target) == False or os.path.isdir(target) == False):
            raise Exception, 'Where is the lib Directory?';
        target = os.path.join(target, 'Models');
        if(os.path.exists(target) == False or os.path.isdir(target) == False):
            os.mkdir(target);
        
        if param.getName() == None:
            if param.getPrefix() == None:
                target = os.path.join(target, 'AutoGenerated.dart');
            else:
                target = os.path.join(target, param.getPrefix() + 'AutoGenerated.dart');
        else:
            if param.getPrefix() == None:
                target = os.path.join(target, param.getName() + '.dart');
            else:
                target = os.path.join(target, param.getPrefix() + param.getName() + '.dart');

        filePath = target;

        # 清空文件
        with open(filePath, 'w') as f:
            f.truncate(0);

    def write(self, content):
        with open(filePath, 'a+') as f:
            f.write(content);

class DartGenerator:
    def __init__(self):
        self.__fileOperator = FileOperator();

    def __getStandardizedObjName(self, name):
        prefix = param.getPrefix();

        if(prefix == None or name.startswith(prefix)):
            return self.__myCapitalize(name);
        return prefix + self.__myCapitalize(name);

    def __Encoding(self, key, value):
        if(type(value) == bool):
            return 'bool';
        elif(type(value) == int):
            return 'int';
        elif(type(value) == float):
            return 'double';
        elif(type(value) == str or type(value) == unicode):
            return 'String';
        elif(type(value) == list):
            if(len(value) == 0):
                return 'List<dynamic>';
            fObj = value[0];
            if(type(fObj) == dict):
                return 'List<' + self.__getStandardizedObjName(key) + '>';
            return 'List<' + self.__Encoding(key, fObj) + '>';
        elif(type(value) == dict):
            return self.__getStandardizedObjName(key);
        else:
            return 'dynamic';

    def generate(self, jsonObj):
        #生成dart文件
        fileContent = '/// This File is Generated by ' + os.path.basename(sys.argv[0]) + ' and you SHOULD NOT MODIFY this file' + os.linesep + \
            '/// UNLESS the property we not recognized named property(number) and mark on the top.' + os.linesep + os.linesep;
        fileContent += self.__writeHeaderImport();
        
        clsName = param.getName();
        if(clsName == None):
            clsName = 'AutoGenerated';
        fileContent += self.__writePartAnnouncement(clsName)
        self.__fileOperator.write(fileContent);

        self.__generateRecursive(jsonObj, self.__getClassName(clsName));

        #生成json解析文件
        (BuildRunnerProcess()).run();

    def __myCapitalize(self, name):
        if(len(name) <= 0):
            return name;
        elif(len(name) == 1):
            return name.capitalize();
        return name[0:1].upper() + name[1:len(name)];

    def __is_contain_chinese(self, check_str):
        for ch in check_str:
            if u'\u4e00' <= ch <= u'\u9fff':
                return True
            return False

    def __getClassName(self, name):
        if(param.getPrefix() == None or name.startswith(param.getPrefix())):
            return self.__myCapitalize(name);
        return param.getPrefix() + self.__myCapitalize(name);

    def __generateRecursive(self, jsonObj, clsName):
        if(type(jsonObj) != dict and type(jsonObj) != list):
            print('');
            print('\033[31m Json Parse Error. Exiting...');
            print('');
            exit();

        fileContent = self.__writeClassHeader(clsName);
        props = []; 

        for (key, value) in jsonObj.items():
            if self.__is_contain_chinese(key): 
                fileContent += os.linesep + '    /// This property we not recognized' + os.linesep + \
                    '    /// You MUST Modify it BY YOURSELF.' + os.linesep;

                name = 'property' + str((len(props) + 1));
                props.append(name);
                fileContent += self.__writeProperty('dynamic', name);
            else:
                props.append(key);
                fileContent += self.__writeProperty(self.__Encoding(key, value), key);

            if(type(value) == dict and len(value.keys()) > 0):
                self.__generateRecursive(value, self.__getClassName(key));
            elif(type(value) == list and len(value) > 0):
                #取最长的元素为参照对象
                obj = None;
                for i in range(0, len(value)):
                    dic = value[i];
                    if type(dic) == dict:
                        if obj == None:
                            obj = dic;
                        else:
                            if len(dic.keys()) > len(obj.keys()):
                                obj = dic;

                if(type(obj) == dict):
                    self.__generateRecursive(obj, self.__getClassName(key));

        fileContent += self.__writeConstruct(clsName, props);

        fileContent += self.__writeFromJsonMethod(clsName);
        fileContent += self.__writeToJsonMethod(clsName);
        fileContent += self.__writeEnding();
        self.__fileOperator.write(fileContent);

    def __writePartAnnouncement(self, clsName):
        fileContent = 'part \'' + self.__getClassName(clsName) + '.g.dart\';' + os.linesep + os.linesep;
        return fileContent;

    def __writeHeaderImport(self):
        fileContent = 'import \'package:json_annotation/json_annotation.dart\';' + os.linesep + os.linesep;
        return fileContent;

    def __writeClassHeader(self, clsName):
        fileContent = '@JsonSerializable(nullable: true)';
        fileContent += os.linesep;
        fileContent += 'class ' + clsName + ' {' + os.linesep;
        return fileContent;

    def __writeProperty(self, typeName, name):
        fileContent = '    ' + typeName + ' ' + name + ';' + os.linesep;
        return fileContent;

    def __writeEnding(self):
        fileContent = '}' + os.linesep + os.linesep;
        return fileContent;
    
    def __writeConstruct(self, clsName, props):
        fileContent = os.linesep + '    ' + clsName + '({';

        isFirst = True;

        count = 0;
        for (idx, p) in enumerate(props):
            count = count + 1;
            if isFirst:
                fileContent += 'this.' + p;
                isFirst = False;
            else:
                fileContent += ', this.' + p;

            if count % 4 == 0 and idx != len(props):
                fileContent += os.linesep + '        ';
        
        fileContent += '});' + os.linesep + os.linesep;
        return fileContent;

    def __writeFromJsonMethod(self, clsName):
        fileContent = '    factory ' + clsName + '.fromJson(Map<String, dynamic> json) => _$' + clsName + 'FromJson(json);';
        fileContent += os.linesep;
        return fileContent;
    
    def __writeToJsonMethod(self, clsName):
        fileContent = '    Map<String, dynamic> toJson() => _$' + clsName + 'ToJson(this);';
        fileContent += os.linesep + os.linesep;
        return fileContent;

class JsonParser(object):
    def __init__(self):
        self.__param = param;
        self.__jsonObj = '';

    def __requestJsonFromURL(self, url):
        response = requests.get(url);
        self.__jsonObj = response.text;

    def __readJsonFromFile(self, path):
        filePath = os.path.expanduser(path);

        if filePath != None:
            try:
                with open(filePath, mode='r') as f:
                    jsonstr = f.readline();
                    if jsonstr != None:
                        self.__jsonObj += jsonstr;
            finally:
                f.close();

    def __readJsonFromString(self):
        jsonstr = raw_input(prompt='press ENTER to exit.');
        while(len(jsonstr) > 0):
            self.__jsonObj += jsonstr;
            jsonstr = raw_input(prompt='press ENTER to exit.');
    
    def parse(self):
        if(self.__param.getMethod() == 1):
            self.__requestJsonFromURL(self.__param.getArgument());
        elif(self.__param.getMethod() == 2):
            self.__readJsonFromFile(self.__param.getArgument());
        elif(self.__param.getMethod() == 3):
            self.__readJsonFromString();
        else:
            exit();

        print('Json Contentes like this below:');
        print('');
        print('\033[31m' + self.__jsonObj + '\033[0m');

        self.__parse();

    def __parse(self):
        print('');
        print('Parsing Json URL, Please Wait...');
        self.__jsonObj = json.loads(self.__jsonObj);
        if(self.__jsonObj != None):
            generator = DartGenerator();
            generator.generate(self.__jsonObj);
        else:
            print('');
            print('Incorrect Json String, Program Will be Exit...');
            exit();

class Paramaters:
    def __init__(self):
        self.__method = 0;                #Parser Method: 1: From URL, 2: From File, 3: From String
        self.__argument = None;           #Parser Argument: (url|filePath)
        self.__target = os.curdir;        #Flutter Project Directory
        self.__name = None;               #Class Name, Default JsonKey
        self.__prefix = None;             #Class Prefix, Default None
        self.__onlyBuild = False;         #Only Build, None Generate

    def getMethod(self):
        return self.__method;
    def setMethod(self, method):
        self.__method = method;
    
    def getArgument(self):
        return self.__argument;
    def setArgument(self, argument):
        self.__argument = argument;
    
    def getTarget(self):
        return self.__target;
    def setTarget(self, target):
        self.__target = os.path.expanduser(target);

    def getName(self):
        return self.__name;
    def setName(self, name):
        self.__name = name;

    def getPrefix(self):
        return self.__prefix;
    def setPrefix(self, prefix):
        self.__prefix = prefix;

    def getOnlyBuild(self):
        return self.__onlyBuild;
    def setOnlyBuild(self, onlyBuild):
        self.__onlyBuild = onlyBuild;

class ArgParser:
    def __help(self):
        print('usage: python/python3 ' + sys.argv[0]);
        print('[-h, --help]: Show This Help Menu.');
        print('[-b, --build]: Only build the target folder');
        print('[-u, --from-url url]: Parse Json Data from Specific URL.');
        print('[-f, --from-file path]: Parse Json Data from Specific FILE.');
        print('[-j, --from-json]: Parse Json Data from Specific JSON STRING.');
        print('[-d, --project-dir dir]: REQUIRED, Specific The Flutter PROJECT DIRECTORY(pubspec.yaml).');
        print('[-c, --model-class className]: Specific The DART CLASS NAME.');
        print('[-p, --class-prefix prefix]: Specific The CLASS NAME PREFIX.');
        print('');

    def __legalArg(self, index):
        if(index + 1 >= len(sys.argv)):
            print('Unknown Argument.');
            print('');
            self.__help();
            exit();

        return True;

    def __isFlutterProject(self, path):
        path = os.path.expanduser(path);
        fileList = os.listdir(path);

        return ('pubspec.yaml' in fileList);

    def parserArgument(self):
        param = Paramaters();

        __index = 1;
        while(__index < len(sys.argv)):
            if(sys.argv[__index] == '-h' or sys.argv[__index] == '--help'):
                self.__help();
                exit();
            elif(sys.argv[__index] == '-u' or sys.argv[__index] == '--from-url'):
                if(self.__legalArg(__index)):
                    param.setArgument(sys.argv[__index + 1]);
                    param.setMethod(1);
                __index = __index + 1;
            elif(sys.argv[__index] == '-f' or sys.argv[__index] == '--from-file'):
                if(self.__legalArg(__index)):
                    param.setArgument(sys.argv[__index + 1]);
                    param.setMethod(2);
                __index = __index + 1;
            elif(sys.argv[__index] == '-j' or sys.argv[__index] == '--from-json'):
                param.setMethod(3);
            elif(sys.argv[__index] == '-d' or sys.argv[__index] == '--project-dir'):
                if(self.__legalArg(__index)):
                    path = sys.argv[__index + 1];
                    if(self.__isFlutterProject(path)):
                        param.setTarget(path);
                    else:
                        raise Exception, 'Invalid Flutter Project Directory.';
                __index = __index + 1;
            elif(sys.argv[__index] == '-c' or sys.argv[__index] == '--model-class'):
                if(self.__legalArg(__index)):
                    param.setName(sys.argv[__index + 1]);
                __index = __index + 1;
            elif(sys.argv[__index] == '-p' or sys.argv[__index] == '--class-prefix'):
                if(self.__legalArg(__index)):
                    param.setPrefix(sys.argv[__index + 1]);
                __index = __index + 1;
            elif(sys.argv[__index] == '-b' or sys.argv[__index] == '--build'):
                param.setOnlyBuild(True);
            else:
                self.__legalArg(len(sys.argv));

            __index = __index + 1;

        return param;

if __name__ == '__main__':
    parser = ArgParser();
    param = parser.parserArgument();

    os.chdir(param.getTarget());
    
    if(param.getOnlyBuild() == True):
        (BuildRunnerProcess()).run();
    else:
        (JsonParser()).parse();